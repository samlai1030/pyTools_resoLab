import os
import sys
import os
import json

import cv2
import numpy as np
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from PyQt5.QtCore import QRect, Qt
from PyQt5.QtGui import QColor, QImage, QPainter, QPen, QPixmap
from PyQt5.QtWidgets import (
    QApplication,
    QFileDialog,
    QInputDialog,
    QLabel,
    QMainWindow,
    QMessageBox,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QScrollArea,
)
from scipy import fftpack
from scipy.ndimage import gaussian_filter, gaussian_filter1d, uniform_filter1d
from scipy.signal import butter, filtfilt, medfilt, savgol_filter, wiener

# Import UI from mainUI.py (generated by pyuic5 from mainUI.ui)
from mainUI import Ui_MainWindow


# Constants
SUPERSAMPLING_FACTOR = 4
EDGE_GRADIENT_THRESHOLD = 50  # Minimum gradient magnitude for edge detection
MAX_FILE_SIZE_MB = 500  # Maximum raw file size in MB
MAX_IMAGE_DIMENSION = 16384  # Maximum image dimension for memory safety
WHITE_REGION_MIN_PERCENT = (
    0.01  # Minimum percentage of pixels for white region analysis
)
EPSILON = np.finfo(float).eps  # Machine epsilon for division by zero protection


def read_raw_image(file_path, width=None, height=None, dtype=np.uint16):
    """
    Read a raw image file with validation and error checking

    Parameters:
    - file_path: path to the raw file
    - width: image width (if known)
    - height: image height (if known)
    - dtype: data type (usually uint8, uint16, or float32)

    Returns:
    - numpy array: loaded image data or None on error

    Raises:
    - ValueError: if file size doesn't match expected dimensions or dtype
    - IOError: if file cannot be read
    - MemoryError: if file is too large
    """
    try:
        # ...existing code...
        file_size = os.path.getsize(file_path)
        max_size_bytes = MAX_FILE_SIZE_MB * 1024 * 1024

        if file_size > max_size_bytes:
            raise MemoryError(
                f"File size ({file_size / (1024**2):.1f} MB) exceeds maximum allowed size ({MAX_FILE_SIZE_MB} MB)"
            )

        # Validate dimensions if provided
        if width and height:
            if width < 1 or width > MAX_IMAGE_DIMENSION:
                raise ValueError(
                    f"Width {width} is out of valid range (1-{MAX_IMAGE_DIMENSION})"
                )
            if height < 1 or height > MAX_IMAGE_DIMENSION:
                raise ValueError(
                    f"Height {height} is out of valid range (1-{MAX_IMAGE_DIMENSION})"
                )

            # Calculate expected file size
            expected_size = width * height * np.dtype(dtype).itemsize
            if file_size != expected_size:
                raise ValueError(
                    f"File size ({file_size} bytes) doesn't match expected size "
                    f"({expected_size} bytes) for {width}x{height} image with dtype {dtype}"
                )

        # Read file data
        with open(file_path, "rb") as f:
            raw_data = f.read()

        # Validate data size is compatible with dtype
        dtype_itemsize = np.dtype(dtype).itemsize
        if len(raw_data) % dtype_itemsize != 0:
            raise ValueError(
                f"File size ({len(raw_data)} bytes) is not divisible by dtype size "
                f"({dtype_itemsize} bytes). Data may be corrupted."
            )

        # Convert to numpy array based on dtype
        if dtype == np.uint16:
            img_array = np.frombuffer(raw_data, dtype=np.uint16)
        elif dtype == np.uint8:
            img_array = np.frombuffer(raw_data, dtype=np.uint8)
        else:
            img_array = np.frombuffer(raw_data, dtype=dtype)

        # Reshape if dimensions are known
        if width and height:
            # Additional safety check before reshape
            if img_array.size != width * height:
                raise ValueError(
                    f"Array size ({img_array.size}) doesn't match dimensions "
                    f"({width}x{height}={width*height})"
                )
            img_array = img_array.reshape(height, width)
        else:
            # Try to guess square dimensions
            total_pixels = len(img_array)
            side = int(np.sqrt(total_pixels))
            if side * side == total_pixels:
                img_array = img_array.reshape(side, side)
            else:
                print(
                    f"Cannot determine image dimensions. Total values: {total_pixels}"
                )
                return img_array

        return img_array

    except (IOError, OSError) as e:
        print(f"Error reading file {file_path}: {e}")
        return None
    except MemoryError as e:
        print(f"Memory error: {e}")
        return None
    except ValueError as e:
        print(f"Validation error: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error reading raw file: {e}")
        return None


class SFRCalculator:
    """物理運算核心：處理邊緣檢測與 SFR 計算"""

    @staticmethod
    def _apply_lsf_smoothing(lsf, method="wiener"):
        """
        應用選定的 LSF 平滑方法

        Parameters:
        - lsf: Line Spread Function 陣列
        - method: 平滑方法
          * "savgol": Savitzky-Golay filter (推薦)
          * "gaussian": 高斯濾波
          * "median": 中值濾波
          * "uniform": 均勻濾波
          * "butterworth": Butterworth IIR 濾波
          * "wiener": Wiener 自適應濾波
          * "none": 不平滑

        Returns:
        - 平滑後的 LSF 陣列
        """
        if method == "none" or len(lsf) <= 5:
            return lsf

        try:
            if method == "savgol":

                # Savitzky-Golay: 保留峰值特性的多項式平滑
                from scipy.signal import savgol_filter

                window_length = min(11, len(lsf) if len(lsf) % 2 == 1 else len(lsf) - 1)
                if window_length < 5:
                    window_length = 5
                return savgol_filter(lsf, window_length=window_length, polyorder=3)

            elif method == "gaussian":
                # 高斯濾波: 簡單平滑
                from scipy.ndimage import gaussian_filter1d

                return gaussian_filter1d(lsf, sigma=1.5)

            elif method == "median":
                # 中值濾波: 對異常值魯棒
                from scipy.signal import medfilt

                kernel_size = min(11, len(lsf) if len(lsf) % 2 == 1 else len(lsf) - 1)
                if kernel_size < 5:
                    kernel_size = 5
                return medfilt(lsf, kernel_size=kernel_size)

            elif method == "uniform":
                # 均勻濾波: 最快的平滑
                from scipy.ndimage import uniform_filter1d

                return uniform_filter1d(lsf, size=5)

            elif method == "butterworth":
                # Butterworth IIR 濾波: 頻率域控制
                try:
                    b, a = butter(2, 0.1)
                    return filtfilt(b, a, lsf)
                except (ValueError, RuntimeError) as e:

                    # Savitzky-Golay: 保留峰值特性的多項式平滑
                    from scipy.signal import savgol_filter

                    # 如果失敗，回退到 Savitzky-Golay
                    print(
                        f"Warning: Butterworth filter failed: {e}, falling back to Savitzky-Golay"
                    )
                    window_length = min(
                        11, len(lsf) if len(lsf) % 2 == 1 else len(lsf) - 1
                    )
                    if window_length < 5:
                        window_length = 5
                    return savgol_filter(lsf, window_length=window_length, polyorder=3)

            elif method == "wiener":
                # Wiener 自適應濾波: 噪聲自適應
                from scipy.signal import wiener

                mysize = min(11, len(lsf) if len(lsf) % 2 == 1 else len(lsf) - 1)
                if mysize < 5:
                    mysize = 5
                return wiener(lsf, mysize=mysize)

            else:
                # 未知方法，使用預設 Savitzky-Golay
                from scipy.signal import savgol_filter

                window_length = min(11, len(lsf) if len(lsf) % 2 == 1 else len(lsf) - 1)
                if window_length < 5:
                    window_length = 5
                return savgol_filter(lsf, window_length=window_length, polyorder=3)

        except Exception as e:
            # 如果任何濾波失敗，返回原始 LSF
            print(f"Warning: LSF smoothing method '{method}' failed: {e}")
            return lsf

    @staticmethod
    def detect_edge_orientation(roi_image):
        """
        檢測邊緣方向：垂直邊(V-edge) 或 水平邊(H-edge)。

        Returns:
        - edge_type: "V-Edge" (垂直), "H-Edge" (水平), or "Mixed"
        - confidence: 0-100, 邊緣方向的置信度
        - details: 詳細信息字典
        """
        if roi_image is None or roi_image.size == 0:
            return "No Edge", 0, {}

        # 轉為灰階
        gray = (
            roi_image
            if len(roi_image.shape) == 2
            else cv2.cvtColor(roi_image, cv2.COLOR_BGR2GRAY)
        )
        gray = gray.astype(np.float64)

        # 使用 Sobel 算子計算梯度
        sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)  # 垂直邊 (x方向梯度)
        sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)  # 水平邊 (y方向梯度)

        # 計算梯度的強度
        mag_x = np.sum(np.abs(sobelx))
        mag_y = np.sum(np.abs(sobely))

        # 計算梯度方向直方圖
        angle = np.arctan2(sobely, sobelx) * 180 / np.pi
        angle = np.mod(angle + 180, 180)  # 將角度標準化到 0-180

        # 統計邊緣方向
        v_edges = (
            np.sum((angle > 80) & (angle < 100)) / angle.size * 100
        )  # 垂直邊 ~90度
        h_edges = (
            np.sum(((angle > 170) | (angle < 10))) / angle.size * 100
        )  # 水平邊 ~0或180度

        # 判定邊緣類型
        edge_strength_ratio = mag_x / (mag_y + 1e-10)

        details = {
            "mag_x": mag_x,
            "mag_y": mag_y,
            "ratio_x_y": edge_strength_ratio,
            "v_edges_percent": v_edges,
            "h_edges_percent": h_edges,
            "mean_x": np.mean(np.abs(sobelx)),
            "mean_y": np.mean(np.abs(sobely)),
        }

        # 根據比率判定邊緣類型
        if edge_strength_ratio > 1.5:
            # 垂直邊：x方向梯度強
            confidence = min(100, (edge_strength_ratio - 1.0) * 50)
            return "V-Edge", confidence, details
        elif edge_strength_ratio < 0.67:
            # 水平邊：y方向梯度強
            confidence = min(100, (1.0 / edge_strength_ratio - 1.0) * 50)
            return "H-Edge", confidence, details
        else:
            # 混合邊
            confidence = 50
            return "Mixed", confidence, details

    @staticmethod
    def validate_edge(roi_image):
        """
        檢測是否為有效的 Slit Edge。
        判斷依據：
        1. 圖像梯度是否足夠強 (有邊緣)。
        2. 邊緣是否接近直線。
        """
        if roi_image is None or roi_image.size == 0:
            return False, "Empty ROI", "No Edge", 0

        # 使用 Sobel 算子計算梯度
        gray = (
            roi_image
            if len(roi_image.shape) == 2
            else cv2.cvtColor(roi_image, cv2.COLOR_BGR2GRAY)
        )
        sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)
        sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)
        magnitude = np.sqrt(sobelx**2 + sobely**2)

        # 簡單判定：最大梯度強度需大於某個閾值
        if np.max(magnitude) < 50:
            return False, "Low Contrast / No Edge detected", "No Edge", 0

        # 檢測邊緣方向
        edge_type, confidence, _ = SFRCalculator.detect_edge_orientation(roi_image)

        return True, "Edge Detected", edge_type, confidence

    @staticmethod
    def calculate_sfr(
        roi_image,
        edge_type="V-Edge",
        compensate_bias=True,
        compensate_noise=True,
        lsf_smoothing_method="savgol",
    ):
        """
        計算 SFR (Spatial Frequency Response) - ISO 12233:2023 Standard with Compensation & LSF Smoothing

        符合 ISO 12233:2023 標準的空間頻率響應測量方法
        支持垂直邊(V-Edge)和水平邊(H-Edge)。
        包括白區域偏差和噪聲補償、LSF 峰值平滑。

        Parameters:
        - roi_image: ROI 圖像
        - edge_type: "V-Edge" 或 "H-Edge"
        - compensate_bias: 補償白區域偏差/亮度偏移 (預設 True)
        - compensate_noise: 補償白區域噪聲 (預設 True)
        - lsf_smoothing_method: LSF 平滑方法 (預設 "savgol")
          * "savgol": Savitzky-Golay filter (推薦，保留峰值特性)
          * "gaussian": 高斯濾波
          * "median": 中值濾波 (對異常值魯棒)
          * "uniform": 均勻平滑濾波 (最快)
          * "butterworth": Butterworth IIR 濾波 (頻率域控制)
          * "wiener": Wiener 自適應濾波 (噪聲自適應)
          * "none": 不進行 LSF 平滑

        Returns:
        - frequencies: 頻率陣列 (cycles/pixel)
        - sfr: SFR 值 (歸一化到 DC = 1)
        - esf: Edge Spread Function
        - lsf: Line Spread Function
        """
        # 轉為灰階並正規化到 0-1 範圍
        img = roi_image.astype(np.float64)
        if len(img.shape) == 3:
            img = np.mean(img, axis=2)

        # 正規化到 0-1
        img_min = np.min(img)
        img_max = np.max(img)
        if img_max > img_min:
            img = (img - img_min) / (img_max - img_min)
        else:
            img = np.zeros_like(img)

        # 步驟 0a: 白區域偏差補償 (White Area Bias Compensation)
        # 補償白區域的亮度偏移/偏差
        if compensate_bias:
            # 提取白區域（值 > 0.9）
            white_mask = img > 0.9
            if np.sum(white_mask) > 10:  # 確保有足夠的白區域樣本
                white_level = np.mean(img[white_mask])
                # 標準白級應為 1.0，計算偏差
                bias_correction = 1.0 - white_level
                # 應用偏差補償
                img = img + bias_correction
                # 確保仍在 [0, 1] 範圍內
                img = np.clip(img, 0, 1)

        # 步驟 0b: 白區域噪聲補償 (White Area Noise Compensation)
        # 通過分析白區域噪聲，應用自適應低通濾波減少噪聲
        if compensate_noise:
            # 提取白區域（值 > 0.85）用於噪聲估計
            white_mask_noise = img > 0.85
            if np.sum(white_mask_noise) > 20:
                # 計算白區域的標準差（噪聲幅度）
                white_noise_std = np.std(img[white_mask_noise])

                # 如果噪聲顯著，應用自適應濾波
                if white_noise_std > 0.01:  # 噪聲閾值
                    from scipy.ndimage import gaussian_filter

                    # 應用高斯濾波，標準差基於測定的噪聲
                    sigma = white_noise_std * 0.5  # 調整濾波強度
                    if edge_type == "V-Edge":
                        # 只在行方向濾波（垂直方向），保留邊緣清晰度
                        img = gaussian_filter(img, sigma=(sigma, 0))
                    else:  # H-Edge
                        # 只在列方向濾波（水平方向），保留邊緣清晰度
                        img = gaussian_filter(img, sigma=(0, sigma))

        # Step 1: 邊緣提取與超採樣 (ISO 12233:2023 Section 7.1)
        if edge_type == "V-Edge":
            # 垂直邊：對寬度方向進行分析
            esf_raw = np.mean(img, axis=0)
            # 使用立方插值進行 4x 超採樣
            from scipy.interpolate import interp1d

            x_orig = np.arange(len(esf_raw))
            f_cubic = interp1d(x_orig, esf_raw, kind="cubic", fill_value="extrapolate")
            x_new = np.linspace(0, len(esf_raw) - 1, (len(esf_raw) - 1) * 4 + 1)
            esf = f_cubic(x_new)
        else:  # H-Edge
            # 水平邊：對高度方向進行分析
            esf_raw = np.mean(img, axis=1)
            from scipy.interpolate import interp1d

            x_orig = np.arange(len(esf_raw))
            f_cubic = interp1d(x_orig, esf_raw, kind="cubic", fill_value="extrapolate")
            x_new = np.linspace(0, len(esf_raw) - 1, (len(esf_raw) - 1) * 4 + 1)
            esf = f_cubic(x_new)

        # Step 2: 亞像素邊緣位置檢測與對齐 (ISO 12233:2023 Section 7.2)
        # ...existing code...
        # 找到 50% 點的位置（邊緣中心）
        esf_min = np.min(esf)
        esf_max = np.max(esf)
        esf_normalized = (esf - esf_min) / (esf_max - esf_min + 1e-10)

        # 找到最接近 50% 的位置
        idx_50 = np.argmin(np.abs(esf_normalized - 0.5))

        # 使用線性插值精細定位 50% 點
        if idx_50 > 0 and idx_50 < len(esf_normalized) - 1:
            # 線性插值找到精確的 50% 位置
            if esf_normalized[idx_50] < 0.5:
                slope = esf_normalized[idx_50 + 1] - esf_normalized[idx_50]
                if slope != 0:
                    frac = (0.5 - esf_normalized[idx_50]) / slope
                else:
                    frac = 0
            else:
                slope = esf_normalized[idx_50] - esf_normalized[idx_50 - 1]
                if slope != 0:
                    frac = (esf_normalized[idx_50] - 0.5) / slope
                else:
                    frac = 0
        else:
            frac = 0

        # 邊緣對齁：移動 ESF 使得 50% 點對齁到整數位置
        edge_pos = idx_50 + frac
        shift_amount = edge_pos - int(edge_pos)

        # 使用循環移位和插值進行邊緣對齁
        if abs(shift_amount) > 1e-6:
            from scipy.ndimage import shift as ndimage_shift

            esf = ndimage_shift(esf, -shift_amount, order=1, mode="nearest")

        # Step 3: 計算 LSF (Line Spread Function)
        # ISO 12233:2023 使用一階差分
        lsf = np.diff(esf)

        # Step 3a: LSF Peak Smoothing - 可選的濾波方法
        # 應用選定的平滑方法以改善 LSF 峰值平滑度
        lsf = SFRCalculator._apply_lsf_smoothing(lsf, method=lsf_smoothing_method)

        # Step 4: 應用視窗函數減少頻譜洩漏 (ISO 12233:2023 推薦 Hann 窗)
        window = np.hanning(len(lsf))
        lsf_windowed = lsf * window

        # Step 5: FFT 轉換進行頻譜分析
        # Validate LSF has sufficient data for FFT
        if len(lsf_windowed) < 4:
            print(
                f"Warning: LSF too short ({len(lsf_windowed)} samples) for FFT analysis"
            )
            return None, None, esf, lsf

        if np.sum(np.abs(lsf_windowed)) < EPSILON:
            print("Warning: LSF sum is too small for meaningful FFT")
            return None, None, esf, lsf

        # 使用 4x 補零以改善頻率解析度
        n_fft = len(lsf_windowed)
        n_fft_padded = n_fft * SUPERSAMPLING_FACTOR
        fft_res = np.abs(fftpack.fft(lsf_windowed, n=n_fft_padded))

        # Step 6: 頻率軸計算與歸一化 (ISO 12233:2023)
        # 考慮超採樣因子（4x），頻率軸需要相應調整
        freqs = fftpack.fftfreq(n_fft_padded, d=0.25)  # 0.25 是超採樣後的像素間距

        # 只取正頻率部分
        n_half = len(freqs) // 2
        sfr = fft_res[:n_half]
        frequencies = freqs[:n_half]

        # 歸一化：將 DC 分量設為 1 (ISO 12233:2023 Section 7.4)
        dc_component = sfr[0]
        if dc_component > EPSILON:
            sfr = sfr / dc_component
        else:
            print(
                f"Warning: DC component too small ({dc_component}), using fallback normalization"
            )
            sfr = sfr / EPSILON

        # 限制 SFR 到合理範圍 [0, 1]
        sfr = np.clip(sfr, 0, 1)

        # Step 7: 返回結果
        # 轉換頻率回到原始像素空間（考慮超採樣）
        # Note: Frequency scaling is already handled in fftfreq with d=0.25
        # No additional division by 4 is needed here to avoid double compensation
        frequencies = frequencies / SUPERSAMPLING_FACTOR

        # 限制頻率範圍到 Nyquist 頻率 (0.5 cycles/pixel)
        valid_idx = frequencies <= 0.5
        frequencies = frequencies[valid_idx]
        sfr = sfr[valid_idx]

        return frequencies, sfr, esf, lsf


class ImageLabel(QLabel):
    """自定義 QLabel 用於處理滑鼠選取 ROI"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.selection_start = None
        self.selection_end = None
        self.is_selecting = False
        self.pixmap_original = None
        self.pixmap_scaled = None
        self.roi_callback = None  # Callback function for ROI selection
        self.zoom_level = 1.0  # Zoom factor
        self.scroll_area = None  # Reference to scroll area
        self.selection_mode = "drag"  # "drag" or "click"
        self.parent_window = parent  # Reference to main window for mode access
        self.selection_info_text = ""  # Display selection info
        self.image_w = 640  # Image width
        self.image_h = 640  # Image height
        self.selection_rect = None  # Store selected 40x40 rectangle
        self.roi_sfr_value = None  # Store SFR value to display at ROI corner
        self.roi_position = None  # Store ROI (x, y, w, h) for SFR display
        self._updating_zoom = False  # Guard flag to prevent recursion
        self.setMouseTracking(True)
        self.setAlignment(Qt.AlignTop | Qt.AlignLeft)

    def mousePressEvent(self, event):
        if not self.pixmap_original:
            return

        # Get current selection mode from parent window
        if self.parent_window and hasattr(self.parent_window, "selection_mode"):
            current_mode = self.parent_window.selection_mode
        else:
            current_mode = "drag"

        if current_mode == "click":
            # Mode 2: Click with user-defined size - Single click to select area centered at click point
            if event.button() == Qt.LeftButton:
                # Clear any old drag selection when new click happens
                self.is_selecting = False
                self.selection_start = None
                self.selection_end = None

                click_pos = event.pos()

                # Get size from parent window (default 30)
                size = 30
                if self.parent_window and hasattr(
                    self.parent_window, "click_select_size"
                ):
                    size = self.parent_window.click_select_size

                half_size = size // 2  # Half size for centering

                # Calculate region centered at click point
                center_x = int(click_pos.x() / self.zoom_level)
                center_y = int(click_pos.y() / self.zoom_level)

                # Area centered at click: half_size pixels on each side
                x = max(0, center_x - half_size)
                y = max(0, center_y - half_size)
                w = size
                h = size

                # Ensure within image bounds
                if x + w > self.image_w:
                    x = max(0, self.image_w - size)
                if y + h > self.image_h:
                    y = max(0, self.image_h - size)

                # Store selection rectangle for drawing
                self.selection_rect = QRect(x, y, w, h)

                # Update selection info
                self.selection_info_text = f"Selected Area: {w}×{h} at ({x}, {y})"
                self.update()

                # Create rectangle and call callback
                rect = QRect(x, y, w, h)
                if self.roi_callback:
                    self.roi_callback(rect)
        else:
            # Mode 1: Drag Select (original behavior)
            if event.button() == Qt.LeftButton and self.pixmap_original:
                # Clear old click selection when new drag starts
                self.selection_rect = None

                self.selection_start = event.pos()
                self.selection_end = event.pos()
                self.is_selecting = True
                self.update()

    def mouseMoveEvent(self, event):
        if self.is_selecting and self.pixmap_original:
            self.selection_end = event.pos()
            self.update()

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton and self.is_selecting:
            self.is_selecting = False
            if self.roi_callback:
                self.roi_callback(self.get_roi_rect())
            self.update()

    def paintEvent(self, event):
        """Override paintEvent to draw selection square and crosshair"""
        super().paintEvent(event)

        # Create single painter for all drawing operations
        painter = QPainter(self)

        # Draw drag selection rectangle
        if self.is_selecting and self.selection_start and self.selection_end:
            painter.setPen(QPen(QColor(255, 0, 0), 2, Qt.DashLine))

            # Draw rectangle directly at current mouse positions (already in zoomed space)
            rect = QRect(self.selection_start, self.selection_end).normalized()
            painter.drawRect(rect)

        # Draw click selection square
        if self.selection_rect and self.pixmap_scaled:
            # Scale rectangle to current zoom level
            scaled_rect = QRect(
                int(self.selection_rect.x() * self.zoom_level),
                int(self.selection_rect.y() * self.zoom_level),
                int(self.selection_rect.width() * self.zoom_level),
                int(self.selection_rect.height() * self.zoom_level),
            )

            # Draw red rectangle outline
            pen = QPen(QColor(255, 0, 0))  # Red
            pen.setWidth(2)
            painter.setPen(pen)
            painter.drawRect(scaled_rect)

            # Draw corner markers
            corner_size = 5
            for corner in [
                (scaled_rect.left(), scaled_rect.top()),
                (scaled_rect.right(), scaled_rect.top()),
                (scaled_rect.left(), scaled_rect.bottom()),
                (scaled_rect.right(), scaled_rect.bottom()),
            ]:
                painter.drawEllipse(
                    corner[0] - corner_size,
                    corner[1] - corner_size,
                    corner_size * 2,
                    corner_size * 2,
                )

        # Draw green crosshair at image center
        if self.pixmap_scaled:
            # Calculate center point in display coordinates
            center_x = self.pixmap_scaled.width() // 2
            center_y = self.pixmap_scaled.height() // 2

            # Draw crosshair
            pen = QPen(QColor(0, 255, 0))  # Green
            pen.setWidth(1)
            painter.setPen(pen)

            # Vertical line
            painter.drawLine(center_x, 0, center_x, self.pixmap_scaled.height())

            # Horizontal line
            painter.drawLine(0, center_y, self.pixmap_scaled.width(), center_y)

        # Draw SFR value at top-left corner of ROI
        if self.roi_sfr_value is not None and self.roi_position is not None:
            x, y, w, h = self.roi_position

            # Convert to display coordinates with zoom
            roi_top_left_x = int(x * self.zoom_level)
            roi_top_left_y = int((y + 5)  * self.zoom_level)

            # Prepare SFR text (show as percentage with 2 decimal places)
            sfr_text = f"{self.roi_sfr_value*100:.2f}%"

            # Setup font for text
            from PyQt5.QtGui import QFont
            font = QFont("Arial", 12)
            font.setBold(True)
            painter.setFont(font)

            # Calculate text size
            metrics = painter.fontMetrics()
            text_width = metrics.horizontalAdvance(sfr_text)
            text_height = metrics.height()

            # Position text at top-left corner (slightly offset inside)
            text_x = roi_top_left_x + 5
            text_y = roi_top_left_y + text_height + 5

            # Draw semi-transparent background box
            bg_rect = QRect(text_x - 3, text_y - text_height - 2,
                           text_width + 6, text_height + 4)

            # Draw background (semi-transparent black)
            painter.fillRect(bg_rect, QColor(0, 0, 0, 200))

            # Draw border (white)
            painter.setPen(QPen(QColor(255, 255, 255), 1))
            painter.drawRect(bg_rect)

            # Draw text (white)
            painter.setPen(QColor(255, 255, 255))
            painter.drawText(text_x, text_y - 3, sfr_text)

        # End painter properly
        painter.end()

    def wheelEvent(self, event):
        """Handle mouse wheel for zooming"""
        if self.pixmap_original is None:
            return

        # Get scroll direction
        delta = event.angleDelta().y()

        # Zoom in/out based on scroll direction
        if delta > 0:
            # Scroll up - zoom in
            self.zoom_level *= 1.1
        else:
            # Scroll down - zoom out
            self.zoom_level /= 1.1

        # Limit zoom level
        self.zoom_level = max(0.5, min(self.zoom_level, 5.0))

        # Update display
        self.update_zoomed_image()

    def update_zoomed_image(self):
        """Update the displayed image with current zoom level"""
        if self.pixmap_original is None or self._updating_zoom:
            return

        # Set guard flag to prevent recursion
        self._updating_zoom = True

        try:
            # Calculate new size
            new_width = int(self.pixmap_original.width() * self.zoom_level)
            new_height = int(self.pixmap_original.height() * self.zoom_level)

            # Scale the pixmap maintaining aspect ratio
            self.pixmap_scaled = self.pixmap_original.scaled(
                new_width, new_height, Qt.KeepAspectRatio, Qt.SmoothTransformation
            )
            self.setPixmap(self.pixmap_scaled)

            # Update size to enable/show scrollbars
            self.setFixedSize(new_width, new_height)
        finally:
            # Always clear guard flag
            self._updating_zoom = False

    def set_roi_sfr_display(self, sfr_value, roi_x, roi_y, roi_w, roi_h):
        """Set SFR value and ROI position to display at top-right corner"""
        self.roi_sfr_value = sfr_value
        self.roi_position = (roi_x, roi_y, roi_w, roi_h)
        self.update()  # Trigger repaint

    def get_roi_rect(self):
        """Get ROI rectangle in image coordinates"""
        if not self.selection_start or not self.selection_end:
            return QRect()

        # Get selected rectangle in display coordinates
        rect = QRect(self.selection_start, self.selection_end).normalized()

        # Account for scroll position if zoomed
        if self.scroll_area and self.zoom_level != 1.0:
            scroll_x = self.scroll_area.horizontalScrollBar().value()
            scroll_y = self.scroll_area.verticalScrollBar().value()
            rect.translate(scroll_x, scroll_y)

        # Convert back to original image coordinates
        if self.zoom_level != 1.0:
            rect = QRect(
                int(rect.x() / self.zoom_level),
                int(rect.y() / self.zoom_level),
                int(rect.width() / self.zoom_level),
                int(rect.height() / self.zoom_level),
            )
        return rect


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # Setup UI from generated mainUI.py
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        # Data
        self.raw_data = None
        self.display_data = None  # Store display data for edge overlay
        self.image_w = 640
        self.image_h = 640

        # LSF Smoothing method selection
        self.lsf_smoothing_method = "none"  # Default method

        # Selection mode: "drag" or "click"
        self.selection_mode = "drag"

        # Click select size (default 40x40)
        self.click_select_size = 40

        # SFR stabilize filter enable/disable
        self.sfr_stabilize_enabled = False

        # View mode: "sfr" for SFR analysis or "view" for panning
        self.view_mode = "sfr"

        # Edge detection threshold
        self.edge_threshold = 50

        # Edge detection display mode
        self.edge_detect_enabled = False
        self.edge_overlay_applied = False
        self.locked_edge_mask = None

        # Recent files list
        self.recent_files = []
        self.max_recent_files = 10
        self.RECENT_FILES_PATH = "recent_files.json"

        # Initialize
        self.load_recent_files()
        self.setup_ui()

    def setup_ui(self):
        """Setup UI - basic initialization"""
        # Setup image label if scroll area exists
        try:
            self.image_label = ImageLabel(self)
            self.ui.scroll_area.setWidget(self.image_label)
            self.image_label.scroll_area = self.ui.scroll_area
        except AttributeError:
            self.image_label = None

        # Setup plots with canvas placeholder
        try:
            self.figure = Figure(figsize=(12, 9), dpi=100)
            self.figure.patch.set_facecolor("white")
            self.canvas = FigureCanvas(self.figure)

            # Create a layout for the placeholder and add the canvas
            if hasattr(self.ui, 'canvas_placeholder'):
                canvas_layout = QVBoxLayout(self.ui.canvas_placeholder)
                canvas_layout.setContentsMargins(0, 0, 0, 0)
                canvas_layout.addWidget(self.canvas)

            self.ax_sfr = self.figure.add_subplot(211)
            self.ax_esf = self.figure.add_subplot(223)
            self.ax_lsf = self.figure.add_subplot(224)

            self.ax_sfr.set_title("SFR / MTF Result", fontsize=11, fontweight="bold")
            self.ax_sfr.set_xlabel("Frequency (cycles/pixel)", fontsize=10)
            self.ax_sfr.set_ylabel("MTF", fontsize=10)
            self.ax_sfr.grid(True, alpha=0.3)

            self.ax_esf.set_title(
                "ESF (Edge Spread Function)", fontsize=10, fontweight="bold"
            )
            self.ax_esf.set_xlabel("Position (pixels)", fontsize=9)
            self.ax_esf.set_ylabel("Intensity", fontsize=9)
            self.ax_esf.grid(True, alpha=0.3)

            self.ax_lsf.set_title(
                "LSF (Line Spread Function)", fontsize=10, fontweight="bold"
            )
            self.ax_lsf.set_xlabel("Position (pixels)", fontsize=9)
            self.ax_lsf.set_ylabel("Derivative", fontsize=9)
            self.ax_lsf.grid(True, alpha=0.3)

            self.figure.tight_layout()
        except Exception as e:
            print(f"Error setting up plots: {e}")
            self.canvas = None

        # Update recent files if combo exists
        try:
            self.update_recent_files_list()
        except Exception:
            pass

    def closeEvent(self, event):
        self.save_recent_files()
        super().closeEvent(event)

    def save_recent_files(self):
        try:
            with open(self.RECENT_FILES_PATH, "w") as f:
                json.dump(self.recent_files, f)
        except Exception as e:
            print(f"Failed to save recent files: {e}")

    def load_recent_files(self):
        try:
            with open(self.RECENT_FILES_PATH, "r") as f:
                self.recent_files = json.load(f)
        except Exception:
            self.recent_files = []

    def update_recent_files_list(self):
        """Update the recent files combo box if it exists"""
        try:
            if hasattr(self.ui, 'recent_files_combo'):
                self.ui.recent_files_combo.clear()
                self.ui.recent_files_combo.addItem("-- Select Recent File --")
                for f in self.recent_files:
                    filename = os.path.basename(f)
                    self.ui.recent_files_combo.addItem(filename, f)
        except Exception:
            pass

    # ...existing code...
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())

